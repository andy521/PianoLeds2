/**
 * @file
 * @copyright (c) 2018 Daniel Schenk <danielschenk@users.noreply.github.com>
 * This file is part of MLC2.
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * @brief std::mutex implementation which uses FreeRTOS
 */

#include "freertos/FreeRTOS.h"
#include "freertos/semphr.h"

#ifndef MUTEX
#define MUTEX

namespace std
{
    template <typename factory>
    class _mutex_base
    {
    public:
        _mutex_base()
        {
            factory f;
            m_handle = f.create_mutex();
        }

        ~_mutex_base()
        {
            vSemaphoreDelete(m_handle);
        }

        _mutex_base(const _mutex_base&) = delete;
        _mutex_base& operator=(const _mutex_base&) = delete;

        void lock()
        {
            xSemaphoreTake(m_handle, portMAX_DELAY);
        }

        void unlock()
        {
            xSemaphoreGive(m_handle);
        }

    private:
        xSemaphoreHandle m_handle;
    };

    class _mutex_factory
    {
    public:
        static xSemaphoreHandle create_mutex()
        {
            return xSemaphoreCreateMutex();
        }
    };

    class _recursive_mutex_factory
    {
    public:
        static xSemaphoreHandle create_mutex()
        {
            return xSemaphoreCreateRecursiveMutex();
        }
    };

    typedef _mutex_base<_mutex_factory> mutex;
    typedef _mutex_base<_recursive_mutex_factory> recursive_mutex;

    template <typename mutex>
    class lock_guard
    {
    public:
        lock_guard(mutex& m)
            : m_mutex(m)
        {
            m_mutex.lock();
        }

        ~lock_guard()
        {
            m_mutex.unlock();
        }

        lock_guard() = delete;
        lock_guard(const lock_guard&) = delete;
        lock_guard& operator=(const lock_guard&) = delete;
    
    private:
        mutex& m_mutex;
    };
}

#endif // MUTEX
